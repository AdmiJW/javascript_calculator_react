{"version":3,"sources":["ButtonsUtil.js","Components/Button.js","Components/ButtonDiv.js","Components/Screen.js","Components/Calculator.js","index.js"],"names":["buttons","mapKeyToBtnId","getPrecedence","getAppendById","zero","one","two","three","four","five","six","seven","eight","nine","decimal","decimalNew","percent","sin","cos","tan","sqrt","pow","add","subtract","multiply","divide","digitLimitExceedTimeOut","pushNewIntoArr","state","btnId","content","inputArray","appendIntoArr","len","length","window","clearTimeout","elem","document","getElementById","innerText","setTimeout","slice","overWrite","getLastStuff","lastElem","test","preProcessEvaluate","str","Number","NaN","endsWith","startsWith","Math","buttonLogics","inputArr","arr","map","e","operandStack","i","isNaN","operand2","pop","operand1","push","String","parseFloat","toFixed","postFixEvaluate","resArr","operatorStack","prevPrecedence","currPrecedence","postFixConversion","negative","isPrevOperator","element","includes","checkFormatting","lastChar","indexOf","lastElemlen","sublastChar","Button","props","btnClicked","currentTarget","id","btn","classList","remove","btnProp","type","className","onClick","mapToDiv","buttonProp","ButtonDiv","key","React","Component","Screen","renderLastElem","bind","renderFormula","join","this","Calculator","audioElem","createElement","addEventListener","click","fetch","then","response","blob","data","fr","FileReader","onload","src","result","readAsDataURL","catch","console","log","currentTime","play","setState","prevState","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.bd4f80da.chunk.js","sourcesContent":["\r\n//  Buttons array used for rendering the button elements. \r\n//  Format:\r\n//  [ <the content, either is the class of FontAwesome or the text>, <id>, <is it Font Awesome?> ]\r\nconst buttons = [\r\n    ['sin', 'sin', false],\r\n    ['cos', 'cos', false],\r\n    ['tan', 'tan', false],\r\n    ['fas fa-superscript', 'pow', true],\r\n    ['fas fa-square-root-alt', 'sqrt', true],\r\n    ['7', 'seven', false],\r\n    ['8', 'eight', false],\r\n    ['9', 'nine', false],\r\n    ['DEL', 'del', false],\r\n    ['AC', 'clear', false],\r\n    ['4', 'four', false],\r\n    ['5', 'five', false],\r\n    ['6', 'six', false],\r\n    ['fas fa-times', 'multiply', true],\r\n    ['fas fa-divide', 'divide', true],\r\n    ['1', 'one', false],\r\n    ['2', 'two', false],\r\n    ['3', 'three', false],\r\n    ['fas fa-plus', 'add', true],\r\n    ['fas fa-minus', 'subtract', true],\r\n    ['fas fa-percentage', 'percent', true],\r\n    ['0', 'zero', false],\r\n    ['.', 'decimal', false],\r\n    ['=', 'equals', false]\r\n];\r\n\r\n//  A mapping used when the user presses a key. Maps the key press to the key ID\r\nconst mapKeyToBtnId = {\r\n    '0': 'zero',\r\n    '1': 'one',\r\n    '2': 'two',\r\n    '3': 'three',\r\n    '4': 'four',\r\n    '5': 'five',\r\n    '6': 'six',\r\n    '7': 'seven',\r\n    '8': 'eight',\r\n    '9': 'nine',\r\n    '+': 'add',\r\n    '-': 'subtract',\r\n    '*': 'multiply',\r\n    '/': 'divide',\r\n    '.': 'decimal',\r\n    '%': 'percent',\r\n    'Backspace': 'del',\r\n    '^': 'pow',\r\n    '=': 'equals'\r\n}\r\n\r\n//  Get the precedence of the operator\r\nconst getPrecedence = {\r\n    '+': 0,\r\n    '-': 0,\r\n    '*': 1,\r\n    '/': 1,\r\n    '^': 2\r\n}\r\n\r\n//  Returns true if the associativity of the operator is Right to Left. If False, then is Left to Right (+ - * /)\r\nfunction getAssociativityRtoL (symbol) {\r\n    return symbol === '^';\r\n}\r\n\r\n//  A mapping from the button element's ID to the actual value that shall be appended into the input Array\r\nconst getAppendById = {\r\n    zero: '0',\r\n    one: '1',\r\n    two: '2',\r\n    three: '3',\r\n    four: '4',\r\n    five: '5',\r\n    six: '6',\r\n    seven: '7',\r\n    eight: '8',\r\n    nine: '9',\r\n    decimal: '.',\r\n    decimalNew: '0.',\r\n    percent: '%',\r\n    sin: 'sin',\r\n    cos: 'cos',\r\n    tan: 'tan',\r\n    sqrt: '√',\r\n    pow: '^',\r\n    add: '+',\r\n    subtract: '-',\r\n    multiply: '*',\r\n    divide: '/'\r\n}\r\n\r\n//  Stores the TimeOut Object when the user trigger a digit limit exceeded. \r\nlet digitLimitExceedTimeOut = null;\r\n\r\n\r\n//  Pushes a new element into the array, based on the Button Id passed in as argument.\r\n//  It is a pure function, so it returns a new array \r\nfunction pushNewIntoArr( state, btnId ) {\r\n\r\n    const content = getAppendById[btnId];   //Get the character to push\r\n\r\n    return [...state.inputArray, content];\r\n}\r\n\r\n//  Appneds the value to be inserted into the last element of the original input Array. By append means append\r\n//  into the string of the last element. Like ['1', '+', '2'], by appending 2 makes ['1', '+', '22']\r\n//  It is a pure function, so it returns a new array \r\nfunction appendIntoArr( state, btnId ) {\r\n\r\n    const len = state.inputArray.length;\r\n    const content = getAppendById[btnId];   //Get the character to append\r\n\r\n    //  If the current string to append is too long (Longer than 16 chars), display warning message\r\n    //  Which dissapear after 500ms by setting TimeOut\r\n    if ( state.inputArray[len - 1].length > 16) {\r\n        if (digitLimitExceedTimeOut) {\r\n             window.clearTimeout( digitLimitExceedTimeOut );\r\n        }\r\n        const elem = document.getElementById('display');\r\n        elem.innerText = 'LIMIT EXCEEDED';\r\n        digitLimitExceedTimeOut = setTimeout(() => {\r\n            elem.innerText = state.inputArray[len - 1];\r\n        }, 500);\r\n        return state.inputArray;\r\n    }\r\n\r\n    return [ ...state.inputArray.slice(0, len - 1), state.inputArray[len - 1] + content ];\r\n}\r\n\r\n\r\n//  Given the button id, will overwrite the last element of the array. Primarily used when overwriting the operators\r\n//  Say the array is ['1', '+'], If user presses -, will overwrite to ['1', '-']\r\n//  It is a pure function, so it returns a new array \r\nfunction overWrite( state, btnId ) {\r\n    const content = getAppendById[btnId];   //Get the character to use to overwrite\r\n\r\n    const len = state.inputArray.length;\r\n    return [ ...state.inputArray.slice(0, len - 1), content ];\r\n}\r\n\r\n\r\n\r\n//  Will get the last 'stuff' of the input Array.\r\n//  If the last stuff is 'NaN' or 'ERROR', return a flag indicating it is an error, which key presses won't do anything\r\n//  If it is sin,cos or tan, then return that\r\n//  Otherwise return the last character of the last element in the input Array\r\nfunction getLastStuff( state ) {\r\n    const len = state.inputArray.length;\r\n    const lastElem = state.inputArray[len - 1];\r\n\r\n    //  If the element is Error, then return a sign indicating ERROR\r\n    if (lastElem === 'NaN' || lastElem === 'ERROR')\r\n        return \"ERR\";\r\n\r\n    //  If the last element ends with trigo function (May be nested, like sincostan ), then return the trigo function\r\n    //  which is the last 3 characters\r\n    if (/.*(sin|cos|tan)$/g.test(lastElem) ) {\r\n        return lastElem.slice( lastElem.length - 3 );\r\n    } \r\n    return lastElem[ lastElem.length - 1 ];     //Else just return the last character\r\n}\r\n\r\n\r\n//  PreProcess the input array. Here are the operations preprocessed:\r\n//  If it ends with %, multiply the value before it by 0.01\r\n//  If it contains trigonometric functions (sin cos tan), then evaluate the trigo function on the value after it\r\n//  If it contains sqrt, then evaluate the trigo function on the value after it\r\n//  Otherwise return the string as it is \r\n\r\n//  Note that this function uses recursion for easier implementation. This makes dealing with nested function and cases\r\n//  like sin( cos( tan( sqrt(x) ) ) ) easier to dealt with\r\nfunction preProcessEvaluate( str ) {\r\n    if (str.length === 0) return Number.NaN;\r\n\r\n    if (str.endsWith('%') ) {\r\n        const len = str.length;\r\n        return `${preProcessEvaluate(str.slice(0, len - 1) ) * 0.01}`;\r\n    }\r\n    if ( str.startsWith('sin') ) {\r\n        return `${Math.sin( preProcessEvaluate(str.slice(3) ) )}`; \r\n    } else if (str.startsWith('cos') ) {\r\n        return `${Math.cos( preProcessEvaluate(str.slice(3) ) )}`;\r\n    } else if (str.startsWith('tan') ) {\r\n        return `${Math.tan( preProcessEvaluate(str.slice(3) ) )}`;\r\n    } else if (str.startsWith('√') ) {\r\n        return `${Math.sqrt( preProcessEvaluate(str.slice(1) ) )}`;\r\n    }\r\n\r\n    return `${str}`;\r\n}\r\n\r\n\r\n\r\n//  This takes in the original input Array, and checks for formatting of the whole array. The formatting done:\r\n//  If the operator is +-, *-, /- or ^- (Meaning the number following shall be negative), then\r\n//  will push the first operator, then set up a flag so that next number gets multiplied by -1\r\n//  If the previous element is an operand (Not operator) and this one is not as well, then insert a multiplication\r\n//  sign between them. See this:     ( 5 sin(3) ) => ( 5 * sin(3) )\r\n\r\n//  This is a pure function, so it returns a new array\r\nfunction checkFormatting( arr ) {\r\n    const resArr = [];\r\n    let negative = false;\r\n    let isPrevOperator = true;\r\n\r\n    for (let i = 0; i < arr.length; i ++ ) {\r\n        const element = arr[i];\r\n\r\n        //  If previous is an operator, then just push this one into the result Array. No need to check if it is \r\n        //  operator. Multiply by -1 if previous operator is negative one ( +- , *- , /-, or ^-)\r\n        if (isPrevOperator) {\r\n            resArr.push( `${element * (negative? -1: 1)}` );\r\n            negative = false;\r\n            isPrevOperator = false;\r\n            continue;\r\n        }\r\n        \r\n        //  If it is a negative operator, push the first operator into the result array, then set the negative flag\r\n        //  to true, which will cause next operand to multiplied by -1\r\n        if ( ['+-', '*-', '/-', '^-'].includes( element) ) {\r\n            resArr.push( element.slice(0, 1) );\r\n            negative = true;\r\n            isPrevOperator = true;\r\n            continue;\r\n        }\r\n        //  Else if it is not an operator, and previous element is not operator ( Like 5 sin 10), then put a \r\n        //  multiply operator in between them\r\n        else if ( !['+', '-', '*', '/', '^'].includes( element) ) {\r\n            resArr.push( '*' );\r\n            resArr.push( element );\r\n            continue;\r\n        }\r\n\r\n        //  All cases exhausted, this must be an operator. \r\n        isPrevOperator = true;\r\n        resArr.push( element);\r\n    }\r\n\r\n    return resArr;\r\n}\r\n\r\n\r\n\r\n//  This function takes in the array of expression in Infix notation, and converts it into postFix notation for\r\n//  easier computer evaluation.\r\n\r\n//  This function is pure function, so it returns a new array \r\nfunction postFixConversion( arr ) {\r\n    const resArr = [];\r\n    const operatorStack = [];\r\n\r\n    for (let i = 0; i < arr.length; i ++ ) {\r\n        const elem = arr[i];\r\n\r\n        //  It is a number. Push into the result array\r\n        if ( !isNaN( elem ) ) {\r\n            resArr.push( elem );\r\n        } else {\r\n            //  If the stack is empty, just push it\r\n            if ( operatorStack.length === 0) {\r\n                operatorStack.push(elem);\r\n                continue;\r\n            }\r\n\r\n            //  Otherwise get the precedences\r\n            const prevPrecedence = getPrecedence[ operatorStack[ operatorStack.length - 1] ];\r\n            const currPrecedence = getPrecedence[ elem ];\r\n\r\n            //  Current operator greater precedence. Push it\r\n            if (currPrecedence > prevPrecedence) operatorStack.push( elem );\r\n            //  Current operator lesser precedence. Pop it and repeat the process\r\n            else if (currPrecedence < prevPrecedence) {\r\n                resArr.push( operatorStack.pop() );\r\n                i --;\r\n            }\r\n            //  Current operators same precedence. Use associativity to compare\r\n            else {\r\n                const RtoL = getAssociativityRtoL( elem );\r\n                if (RtoL) {\r\n                    operatorStack.push( elem );\r\n                } else {\r\n                    resArr.push( operatorStack.pop() );\r\n                    i --;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //  Push the remanining operators into the result Array\r\n    while ( operatorStack.length > 0 ) {\r\n        resArr.push( operatorStack.pop() );\r\n    }\r\n\r\n    return resArr;\r\n}\r\n\r\n\r\n//  This function takes in an array of expression in PostFix notation, and evaluates them into\r\n//  an array of length one, consisting of final answer\r\n\r\n//  This is a pure function, so it will return a new array\r\nfunction postFixEvaluate( arr ) {\r\n    const operandStack = [];\r\n\r\n    for (let i of arr ) {\r\n        //  It is a number, push into operand stack\r\n        if ( !isNaN(i) ) operandStack.push(i);\r\n        else {\r\n            const operand2 = operandStack.pop();\r\n            const operand1 = operandStack.pop();\r\n            switch(i) {\r\n                case '+':\r\n                    operandStack.push( Number(operand1) + Number(operand2) );\r\n                    break;\r\n                case '-':\r\n                    operandStack.push( Number(operand1) - Number(operand2) );\r\n                    break;\r\n                case '*':\r\n                    operandStack.push( Number(operand1) * Number(operand2) );\r\n                    break;\r\n                case '/':\r\n                    operandStack.push( Number(operand1) / Number(operand2) );\r\n                    break;\r\n                case '^':\r\n                    operandStack.push( Number(operand1) ** Number(operand2) );\r\n                    break;\r\n                default: break;\r\n            }         \r\n        }\r\n    }\r\n\r\n    //  At the end, if what remains in the operand Stack is not the single answer, return ERROR array\r\n    if (operandStack.length !== 1) return ['ERROR'];\r\n    \r\n    //  Format the answer to fixed precision\r\n    operandStack[0] = String( parseFloat( Number(operandStack[0]).toFixed(10) ) );\r\n    return operandStack;\r\n}\r\n\r\n\r\n//  This function is used when the user presses a key. Determines the key's function, and perform related operations\r\n//  Returns the new, modified array after the action had been performed.\r\n\r\n//  This is a pure function, so it returns a new array\r\nfunction buttonLogics ( state, btnId ) {\r\n    const inputArr = state.inputArray;\r\n    const len = inputArr.length;\r\n\r\n    switch (btnId) {\r\n        case 'equals':\r\n            let arr = state.inputArray.map( e => preProcessEvaluate(e) );\r\n            arr = checkFormatting( arr );\r\n            arr = postFixConversion( arr );\r\n            return postFixEvaluate(arr);\r\n        case 'clear':\r\n            return [];\r\n        case 'zero':\r\n            // If empty array or it only consists of single zero, do nothing\r\n            if (!len || inputArr[len - 1] === '0') return inputArr;\r\n        case 'one':\r\n        case 'two':\r\n        case 'three':\r\n        case 'four':\r\n        case 'five':\r\n        case 'six':\r\n        case 'seven':\r\n        case 'eight':\r\n        case 'nine':\r\n            //  Empty input array. Push directly\r\n            if (!len) return pushNewIntoArr( state, btnId );\r\n            //  Else if consist of single zero only, overwrite the zero\r\n            else if ( inputArr[len - 1] === '0' ) return overWrite( state, btnId);\r\n            else {\r\n                const lastChar = getLastStuff( state );\r\n                \r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n\r\n                //  Last element is operator. Push new element\r\n                if ( ['+', '-', '*', '/', '^', '%'].includes(lastChar) ) {\r\n                    return pushNewIntoArr( state, btnId );\r\n                }\r\n                else {\r\n                    return appendIntoArr( state, btnId );\r\n                }\r\n            }\r\n        case 'decimal':\r\n            //  Empty input array. Push directly\r\n            if (!len) return pushNewIntoArr( state, 'decimalNew' );\r\n            else {\r\n                const lastChar = getLastStuff( state );\r\n\r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n                //  Last one is trigo functions or sqrt. Append 0.\r\n                if ( ['sin','cos','tan','√'].includes(lastChar) ) return appendIntoArr(state, 'decimalNew');\r\n                //  Last one is operator. Push new element\r\n                else if ( ['+', '-', '*', '/', '^', '%'].includes(lastChar) ) return pushNewIntoArr(state, 'decimalNew');\r\n                else {\r\n                    const lastElem = state.inputArray[ len - 1];\r\n                    if (lastElem.indexOf('.') !== -1 ) return state.inputArray;\r\n                }\r\n            }\r\n            return appendIntoArr(state, 'decimal');\r\n\r\n        case 'percent':\r\n            //  Empty input array. Do nothing\r\n            if (!len) return state.inputArray;\r\n            else {\r\n                const lastChar = getLastStuff( state);\r\n\r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n                //  Non numbers. Do nothing\r\n                if ( ['sin', 'cos', 'tan', '√', '+' ,'-', '*', '/', '^', '%'].includes(lastChar) ) return state.inputArray;\r\n                return appendIntoArr( state, btnId );\r\n            }\r\n\r\n        case 'del':\r\n            //  Empty input array. Do nothing\r\n            if (!len) return state.inputArray;\r\n            else {\r\n                const lastChar = getLastStuff( state );\r\n\r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n\r\n                const lastElem = state.inputArray[ len - 1];\r\n                const lastElemlen = lastElem.length;\r\n\r\n                //  If the last element only consists of single character, just remove the element entirely\r\n                if ( lastElemlen === 1) return [...state.inputArray.slice(0, len - 1) ];\r\n                //  If the last element is sin cos or tan, we need to remove those 3 characters trigo function\r\n                //  If it consists of just one trigo function (Not nested like sincostan), remove the element entirely\r\n                else if ( ['sin','cos','tan'].includes(lastChar) ) {\r\n                    if (lastElemlen === 3 ) return [...state.inputArray.slice(0, len - 1) ];\r\n                    return [...state.inputArray.slice(0, len-1), lastElem.slice(0, lastElemlen - 3) ];\r\n                }\r\n                //  Remove single character only, not remove element\r\n                return [...state.inputArray.slice(0, len - 1), lastElem.slice(0, lastElemlen - 1) ];\r\n            }\r\n\r\n        case 'sin':\r\n        case 'cos':\r\n        case 'tan':\r\n        case 'sqrt':\r\n            //  Empty input array. Push directly\r\n            if (!len) return pushNewIntoArr(state, btnId);\r\n            else {\r\n                const lastChar = getLastStuff( state );\r\n\r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n\r\n                const lastElem = state.inputArray[ len - 1];\r\n\r\n                //  If it is same of a kind, append\r\n                if ( ['sin', 'cos', 'tan', '√'].includes(lastChar) ) return appendIntoArr( state, btnId );\r\n                //  If last element consists of single zero only, overwrite the single zero\r\n                else if (lastElem === '0') return overWrite( state, btnId );\r\n                //  Last element probably is operator or number. Push new element\r\n                else return pushNewIntoArr( state, btnId );\r\n            }\r\n\r\n        case 'pow':\r\n            //  Empty input array. Do nothing\r\n            if (!len) return state.inputArray;\r\n            else {\r\n                const lastChar = getLastStuff(state);\r\n\r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n\r\n                //  Operator. Overwrite it\r\n                if ( ['+', '-', '*', '/', '^'].includes(lastChar) ) return overWrite( state, btnId );\r\n                //  trigo functions or sqrt. Do nothing\r\n                else if ( ['sin', 'cos', 'tan', '√'].includes(lastChar) ) return state.inputArray;\r\n                else return pushNewIntoArr( state, btnId );\r\n            }\r\n\r\n        case 'subtract':\r\n            //  Empty input array. Do nothing\r\n            if (!len) return state.inputArray;\r\n\r\n            //  Use sublastChar so it won't conflict with the fallthrough case of switch statements\r\n            let sublastChar = getLastStuff(state);\r\n            if (sublastChar === 'ERR') return inputArr;\r\n\r\n            //  If it is + * or /, append it\r\n            if ( ['+', '*', '/' ].includes(sublastChar) ) return appendIntoArr(state, btnId );\r\n        case 'add':\r\n        case 'multiply':\r\n        case 'divide':\r\n            //  Empty input array. Do nothing\r\n            if (!len) return state.inputArray;\r\n            else {\r\n                const lastChar = getLastStuff(state);\r\n\r\n                //  Error, do nothing\r\n                if (lastChar === 'ERR') return inputArr;\r\n\r\n                //  Operator. Just overwrite it\r\n                if ( ['+', '-', '*', '/', '^'].includes(lastChar) ) return overWrite( state, btnId );\r\n                //  trigo function or sqrt. Do nothing\r\n                else if ( ['sin', 'cos', 'tan', '√'].includes(lastChar) ) return state.inputArray;\r\n                return pushNewIntoArr( state, btnId );\r\n            }\r\n        \r\n        default: return inputArr;\r\n    }\r\n\r\n}\r\n\r\n\r\nexport { buttons, buttonLogics, mapKeyToBtnId };","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nfunction Button(props) {\r\n\r\n    //  Function called when button is pressed\r\n    const btnClicked = (e) => {\r\n        const btnId = e.currentTarget.id;\r\n        const btn = document.getElementById(btnId);\r\n        props.btnClicked( btnId );\r\n\r\n        //  Add .pressed class to the button to create visual effect of button press\r\n        btn.classList.add('pressed');\r\n        setTimeout( () => {\r\n            btn.classList.remove('pressed');\r\n        }, 200);\r\n    }\r\n\r\n\r\n    //  This function takes in the button array, and returns the respective JSX for it\r\n    //  This function exists because some buttons use FontAwesome, and some just pure text inside button\r\n    const mapToDiv = (btnProp) => {\r\n        const [ content , id, isFontAwesome ] = btnProp;\r\n\r\n        if (isFontAwesome) {\r\n            return (\r\n                <button type='button' className='button' id={ id } onClick={ btnClicked } >\r\n                    <i className={ content } />\r\n                </button>\r\n            );\r\n        } else {\r\n            return (\r\n                <button type='button' className='button' id={ id } onClick={ btnClicked } >{content}</button>\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    //  Returned JSX is here\r\n    return mapToDiv(props.buttonProp);\r\n\r\n}\r\n\r\nButton.propTypes = {\r\n    btnClicked: PropTypes.func.isRequired,\r\n    buttonProp: PropTypes.array.isRequired\r\n}\r\n\r\nexport default Button;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { buttons } from '../ButtonsUtil';\r\n\r\nimport Button from './Button';\r\n\r\n\r\nclass ButtonDiv extends React.Component {\r\n\r\n\r\n    render() {\r\n        \r\n        //  The function which when take in a button array, will convert into respective JSX button element\r\n        const mapToDiv = (btn) => {\r\n            return (\r\n                <Button buttonProp={ btn } key={ btn[1] } btnClicked={ this.props.btnClicked } />\r\n            );\r\n        }\r\n        \r\n\r\n        return (\r\n        //-----------------------JSX------------------------------\r\n        <div className='buttons' id='buttons'>\r\n            { \r\n                buttons.map( btn => mapToDiv(btn) )\r\n            }\r\n        </div>\r\n\r\n        //--------------------------------------------------------\r\n        )\r\n    }\r\n\r\n}\r\n\r\n\r\nButtonDiv.propTypes = {\r\n    btnClicked: PropTypes.func.isRequired\r\n}\r\n\r\n\r\nexport default ButtonDiv;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nclass Screen extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.renderLastElem = this.renderLastElem.bind(this);\r\n        this.renderFormula = this.renderFormula.bind(this);\r\n    }\r\n\r\n    //  Takes in the input Array. Concat the contents of the input array into one single string seperated by spaces\r\n    renderFormula( inputArr ) {\r\n        return inputArr.join(\" \");\r\n    }\r\n\r\n    //  IF input array is empty, return 0\r\n    //  else return the last element of input array as string\r\n    renderLastElem( inputArr ) {\r\n        const len = inputArr.length;\r\n        if (!len) return '0';\r\n        return inputArr[ len - 1];\r\n    }\r\n\r\n\r\n    render() {\r\n        const inputArr = this.props.inputArray;\r\n        return (\r\n        //--------------------------JSX--------------------------------\r\n\r\n        <div className='screen'>\r\n            <div className='screen-formula'>\r\n                { this.renderFormula( inputArr) }\r\n            </div>\r\n            <hr/>\r\n            <div className='screen-last' id='display'>\r\n                { this.renderLastElem( inputArr) }\r\n            </div>\r\n            \r\n        </div>\r\n\r\n        //-------------------------------------------------------------\r\n        )\r\n    }\r\n}\r\n\r\nScreen.propTypes = {\r\n    inputArray: PropTypes.array.isRequired\r\n}\r\n\r\n\r\nexport default Screen;","import React from 'react';\r\n\r\nimport ButtonDiv from './ButtonDiv';\r\nimport Screen from './Screen';\r\n\r\nimport { buttonLogics, mapKeyToBtnId } from '../ButtonsUtil';\r\n\r\nclass Calculator extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.btnClicked = this.btnClicked.bind(this);\r\n\r\n        this.audioElem = document.createElement('audio');\r\n    }\r\n\r\n    componentDidMount() {\r\n        //  Event listener for user keyboard press\r\n        document.addEventListener('keydown', (e) => {\r\n            if ( e.key in mapKeyToBtnId ) {\r\n                document.getElementById( mapKeyToBtnId[e.key] ).click();\r\n            }\r\n        });\r\n\r\n        fetch('https://raw.githubusercontent.com/AdmiJW/Items/master/Misc/office-calculator-single-button-press.mp3')\r\n        .then(response => response.blob() )\r\n        .then(data => {\r\n            const fr = new FileReader();\r\n            fr.onload = () => {\r\n                this.audioElem.src = fr.result;\r\n            }\r\n\r\n            fr.readAsDataURL(data);\r\n        })\r\n        .catch(e => {\r\n            console.log('Fetching failed. Setting sound file directly as URL')\r\n            this.audioElem.src = 'https://raw.githubusercontent.com/AdmiJW/Items/master/Misc/office-calculator-single-button-press.mp3'\r\n        });\r\n\r\n    }\r\n    \r\n    state = {\r\n        inputArray: []\r\n    }\r\n\r\n\r\n    //  Triggered when button is clicked. This function is passed down until the individual Button element as callback\r\n    //  (Drilling). This is because to use setstate in this Component only\r\n    btnClicked( btnId ) {\r\n        this.audioElem.currentTime = 0;\r\n        this.audioElem.play();\r\n\r\n        this.setState( (prevState) => ({\r\n            inputArray: buttonLogics( prevState, btnId )\r\n        }) );\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        // ---------------------------JSX--------------------------------\r\n            \r\n            <div className='calculator' id='calculator'>\r\n                <Screen inputArray={ this.state.inputArray } />\r\n                <ButtonDiv btnClicked={this.btnClicked} />\r\n            </div>\r\n\r\n        //--------------------------------------------------------------\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\nexport default Calculator;","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport Calculator from './Components/Calculator';\n\nimport './Style/style.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Calculator />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n\n"],"sourceRoot":""}